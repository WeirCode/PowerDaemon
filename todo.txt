parser_run.add_argument("-time", type=int, required=True, help="Total duration in seconds")
parser_run.add_argument("-freq", type=float, required=True, help="Sampling frequency in Hz")
interval_ms = int(1000 / args.freq)
def run_perf(events, duration, interval_ms, cgroup_path=None, label="system"):
    cmd = [
        "perf", "stat",
        "-I", str(interval_ms),
        "-e", ",".join(events),
        "sleep", str(duration)
    ]
    
    if cgroup_path:
        cmd += ["-G", cgroup_path]

    print(f"Running perf for {label}: {' '.join(cmd)}")
    return subprocess.Popen(cmd, stderr=subprocess.PIPE, stdout=subprocess.PIPE, text=True)
proc_sys = run_perf(events, duration, interval_ms, label="system")
proc_cg = run_perf(events, duration, interval_ms, cgroup_path=args.cgroup, label="cgroup")

sys_output, _ = proc_sys.communicate()
cg_output, _ = proc_cg.communicate()
from datetime import datetime, timedelta

def parse_perf_output(raw_output, start_time, label):
    lines = raw_output.strip().split("\n")
    data = []

    for line in lines:
        parts = line.strip().split()
        if len(parts) >= 5 and parts[1] != "<not":
            try:
                elapsed = float(parts[0]) / 1000  # ms â†’ s
                timestamp = start_time + timedelta(seconds=elapsed)
                value = parts[1].replace(",", "")
                unit = parts[2]
                event = parts[3]
                data.append([timestamp.isoformat(), float(value), unit, event])
            except ValueError:
                continue

    # Write to CSV
    import csv
    filename = f"perf_{label}.csv"
    with open(filename, "w", newline="") as f:
        writer = csv.writer(f)
        writer.writerow(["timestamp", "value", "unit", "event"])
        writer.writerows(data)

    return filename
import pandas as pd
import matplotlib.pyplot as plt

def generate_graphs(system_csv, cgroup_csv):
    sys_df = pd.read_csv(system_csv)
    cg_df = pd.read_csv(cgroup_csv)

    events = sys_df['event'].unique()

    for event in events:
        sys_event_df = sys_df[sys_df['event'] == event]
        cg_event_df = cg_df[cg_df['event'] == event]

        plt.figure(figsize=(10, 5))
        plt.plot(sys_event_df['timestamp'], sys_event_df['value'], label="System")
        plt.plot(cg_event_df['timestamp'], cg_event_df['value'], label="Cgroup")

        plt.title(f"Event: {event}")
        plt.xlabel("Time")
        plt.ylabel(f"Value ({sys_event_df['unit'].iloc[0]})")
        plt.legend()
        plt.grid(True)
        plt.xticks(rotation=45)
        plt.tight_layout()
        plt.savefig(f"plot_{event.replace('/', '_')}.png")
        plt.close()
start_time = datetime.now()

# Start subprocesses
proc_sys = run_perf(..., label="system")
proc_cg  = run_perf(..., label="cgroup")

# Wait and collect output
sys_output, _ = proc_sys.communicate()
cg_output, _  = proc_cg.communicate()

# Parse to CSV
sys_csv = parse_perf_output(sys_output, start_time, "system")
cg_csv  = parse_perf_output(cg_output,  start_time, "cgroup")

# Generate comparison graphs
generate_graphs(sys_csv, cg_csv)

print("Monitoring complete. CSV and plots saved.")
sudo python3 collector.py run \
    -cgroup mygroup.slice \
    -detail 2 \
    -time 15 \
    -freq 2
